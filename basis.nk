this #<| [
  "( -- ): moves stack cursor once to the left."
  stack |at 1 - stack swap |to
] opens


this #|> [
  "( -- ): moves stack cursor once to the right."
  stack |at 1 + stack swap |to
] opens


this #ahead [
  "( -- B ): leaves caller Block on the stack."
  conts dup count 3 - fromLeft #block entry:fetch
] opens


this #burp [
  "( B F -- ): inserts Form to Block: adds Form to Block,
   and moves cursor back again."
  <| dup |> shove dup |at 1 - |to
] opens


this #there [
  "( S B -- S ): opens Block in Stack, leaves Stack. Ahead
   is transferred to block."
  <| dup |> ahead #hydrate burp
] opens


this #eject [
  "( [ ... | F ... ]B -- [ ... | ... ]B -- F ): drops and
   leaves the Form after cursor in Block."
  [ |> ] there cherry
] opens


this #@: [
  "( F @: N ): makes an opener entry called Name for Form."
  ahead swap ahead eject swap opens
] opens

[ "( F $: N -- ): makes a pusher entry called Name for Form."
  ahead swap ahead eject swap pushes
] @: $:


[ "( V =: N -- ): submits Value to an already defined entry
   under the specified Name."
  ahead swap ahead eject swap submit
] @: =:


[ "( A B -- ): drops a pair of forms."
  drop drop
] @: 2drop


[ "( A B -- B ): drops over the top."
  swap drop
] @: nip


[	"( A B -- A B A ): duplicates over the top."
  <| dup |> swap
] @: over


[ "( A B C -- B C A ): brings thirdmost to the top."
  <| swap |> swap
] @: rot


[ "( A B C -- C A B ): makes top third from the top."
  rot rot
] @: -rot


[ "( A B -- A B A B ): duplicates a pair."
  over over
] @: 2dup


[ "( F [ ... ] -- [ ... F ] -- ): adds Form to Block, then
   drops both."
  swap shove
] @: gulp


[ "( [ ... ] F -- [ ... F ] ): inserts Form into block."
  over gulp
] @: <<


[ "( [ ... F ] -- [ ... ] F ): removes Form from block, leaves both."
  dup cherry
] @: >>


[ "( F -- [ F ] ): wraps Form in a new block."
  [ ] swap <<
] @: enclose


[ "( A B -- [ A B ] ): wraps a pair of forms in a new block."
  swap

  [ ] swap <<
      swap <<
] @: 2enclose


[ "( [ ... T ]B -- [ ... T ]B T ): leaves Block and its Top value."
  >> dup <| << |>
] @: top


[ "( B I -- F ): returns Index-th Form from right in Block;
   I = 0 is the last (rightmost) element."
  over count 1 - swap - fromLeft
] @: fromRight


[ "( T -> N -- F ): infix for `fetch`."
  ahead eject entry:fetch
] @: ->


[ "( T . N -- F ): same as `->`, but adds `open` ahead if the
   entry is an open(er) entry."
  ahead                $: caller
  ahead eject          $: name
  dup name entry:fetch $: form

  name entry:isOpenEntry? => [
    caller [ #open <| ] hydrate
  ]

  form
] @: .


[ "( A B -- true/false ): leaves whether two values are equal."
  same?
] @: =


[ "( A B -- true/false ): leaves whether A <= B."
  2dup < -rot = or
] @: <=


[ "( A B -- true/false ): leaves whether A > B."
  <= not
] @: >


[ "( A B -- true/false ): leaves whether A >= B."
  < not
] @: >=


[ "( A -- true/false ): leaves whether A = 0"
  0 =
] @: zero?


[ "( A B -- true/false ): leaves whether A is divisible by B."
  rem zero?
] @: /?


[ "( N -- true/false ): leaves whether A is even (divisible by two)."
  2 /?
] @: even?


[ "( N -- true/false ): leaves whether A is odd."
  even? not
] @: odd?


[ "( B -- true/false ): leaves whether Block is empty."
  count zero?
] @: empty?


[ "( F -- I ): leaves Inverse of Form (false => true, else false)."
  false same?
] @: not


[ "( F --  B ): leaves Form as Boolean."
  not not
] @: true?


[ "( B -- B' ): opens Block in the active stack."
  stack swap ahead #hydrate burp
] @: open


[ "( B -- T ): activates an empty stack for the duration of Block,
   and leaves Top form in the stack. Dies if none."
  [ ] swap there cherry
] @: val


[ "( B -- ): activates an empty stack for the duration of Block."
  [ ] swap hydrate
] @: do


[ "( D T F -- ? ): opens True/False forms depending on Determiner
   being true/false."
  sel open
] @: br


[ "( D => T -- ? ): opens True form if Determiner is truthy."
  ahead eject [ ] br
] @: =>


[ "( A B -- A/false ): leaves whether both A and B are truthy."
  $: b @: a

  a b false br
] @: and


[ "( A B -- true/A ): leaves whether A or B or both are truthy."
  $: b @: a
  
  a true b br
] @: or


[ "( T N fetch: B -- ): looks up under Name in Table block,
   and opens Block with that on ToS (on caller stack). If not
   found (or T is not block), does nothing."
  ahead eject @: block

  [ over block? ] [ 2dup entry:exists? ] and
    [ entry:fetch block ] "Has the entry, fetch and open block."
    [ 2drop             ] "Doesnt have, drop T N."
  br
] @: fetch:


[ "( B -- ): makes detached continuations stack the stack for
   the duration of Block. Attaches after Block."
  conts detach
    "Don't forget to drop the call to continues (as it will
     obscure what the caller expects continuations block to be)"
    [ drop ] there swap there
  conts attach
] @: continues


[ "( -- ): executes caller again. Looping primitive. Too low-
   level for users, prefer not to use (use `loop` instead).
   Beware that it does not re-instantiate the block."
  [
    drop "the call to repeat"
    dup -> block 0 |to
  ] continues
] @: repeat


[ "( B -- ): drops all continuations before (and including)
   those for which Block leaves truthy value when opened with
   the continuation on top of an empty stack, coming from the
   right-hand side."
  $: needle?

  [
    enclose needle? there cherry
      [ ]  "Hit the needle! Don't recurse."
      rec  "Not the needle. Recurse."
    br
  ] dup $: rec continues
] @: dropContinuationsUntil


[ "( -- ): returns to the CC of the block above the caller."
  ahead prototype parent $: above

  [ -> block prototype above same? ] dropContinuationsUntil
] @: ^


[ "( B -- I ): injects `break` and `continue` into an Instance
   of Block. `break` drops continuations until and including
   the caller block, and `continue`, drops them up to and
   including the Body block (and/or its instances)."
    dup $: body
    new $: instance
  ahead $: caller

  instance #break [ "( -- ): quits from the enclosing loop."
    [ -> block caller same? ] dropContinuationsUntil
  ] opens

  instance #continue [ "( -- ): quits from current loop iteration."
    [ -> block prototype body same? ] dropContinuationsUntil
  ] opens

  instance
] @: newWithBreakAndContinue


[ "( B -- ): basic infinite loop over Block. `break` and `continue`
   are made available in Block. Block is opened in an empty stack."
  newWithBreakAndContinue $: block

  [ "The actual loop body (note the `repeat`)."
    [ ] new block hydrate

    repeat
  ] open
] @: loop


[ "( loop: B -- ): prefix version of `loop`. Has no difference
   in regards to functionality."
  ahead eject loop
] @: loop:


[ "( C B -- ): opens Condition in caller's stack, Body in a
   new stack with Condition's result on top, all while this
   result is truthy. Similar to `loop`, words `break` and
   `continue` are made available in Body."
  newWithBreakAndContinue $: body $: condition stack $: cStack

  loop: [
    cStack condition there cherry dup
      [ enclose body there ] "Condition truthy: enclose & proceed with body!"
      [ drop break ]         "Condition falsey: drop the false and get out."
    br
  ]
] @: while


[ "( while: C B -- ): prefix version of `while`. Has no difference
   in regards to functionality."
  ahead eject
  ahead eject
  while
] @: while:


[ "( C B -- ): inverse of `while` (opens Body while Condition
   is **false**), for more info see `while`."
  $: body @: condition

  [ condition not ] body while
] @: until


[ "( until: C B -- ): prefix version of `until`. Has no difference
   in regards to functionality."
  ahead eject
  ahead eject
  until
] @: until:


[ "( N B -- ): opens Body N times. Body is opened in a new
   stack with current N. `break` and `continue` available."
  newWithBreakAndContinue $: body $: stop

  0 $: start

  while: [ start stop < ] [
    start enclose body there
    start 1 + =: start
  ]
] @: times


[ "( N times: B -- ): infix version of `times`."
  ahead eject times
] @: times:


[ """( Lb B -- Lb ): slides cursor in List block from left to
   right, in steps of one, and THEN opens Block with List block
   as the stack each step. Leaves List block. `break` and `continue`
   are available.

  >>> [ 1 2 3 ] dup 1 |to [ + ] |slideRight

  ! Sliding step is marked with '*', block iteration postfixed
    by a '+'.

   +------+-------+-------------+ 
   | #    | form  |    list     |
   +======+=======+=============+
   | 0    |       | [ 1 2 3 | ] |
   | 1    | 1 |to | [ 1 | 2 3 ] |
   | *    |       | [ 1 2 | 3 ] |
   | 3+   |    +  | [ 3 | 3 ]   |
   | *    |       | [ 3 3 | ]   |
   | 5+   |    +  | [ 6 | ]     |
   +------+-------+-------------+

  === [ 6 ]
  """
  newWithBreakAndContinue $: body $: list

  until: [ list dup |at over count = ]
  [
    list dup |at 1 + |to
    list body there
  ]

  list
] @: |slideRight


[ "( Lb |-> B -- Lb ): infix version of `|slideRight`."
  ahead eject |slideRight
] @: |->


[ "( Lb B -- Lb ): similar to `|->`, but slides the cursor
   from right to left. Consult `|slideRight`."
  newWithBreakAndContinue $: body new $: list

  until: [ list |at 0 = ]
  [
    list count $: tmp
    list body there
    list count tmp >= => [
      "If the amount of items in the list has not
       changed, or increased, slide leftwards."
       list dup |at 1 - |to
    ]
  ]

  list
] @: |slideLeft


[ "( Lb <-| B -- Lb ): infix version of `|slideLeft`."
  ahead eject |slideLeft
] @: <-|


[ "( Lb B -- ): opens Block with each item in List block on
   top of a new stack. List block is unchanged. `break` and
   `continue` are available."
  newWithBreakAndContinue $: block

  new dup 0 |to |-> [ dup enclose block hydrate ] drop
] @: each


[ "( Lb each: B -- ): infix version of `each`. "
  ahead eject each
] @: each:


[ "( F -- ): prints Form in the console. If Form is a block
   with *view word defined, opens *view in an empty stack
   and prints ToS form after *view there."
  dup #*view fetch: [
    "If there's a *echo word defined on the block, print
     whatever ToS it leaves."
    val rawEcho drop ^
  ]
  rawEcho
] @: echo


[ "( Q1 ~ Q2 -- Q ): infix Quote stitch (binary concatenation).
  TODOOOOOOOOO"
  ahead       $: caller
  ahead eject $: other 

  other dup word? => [ caller swap entry:fetch ] stitch
] @: ~


[ "( Pq -- P ): exchanges Path quote for a Path block with
   path-related vocabulary."
  $: pathQuote

  [ "( -- true/false ): same as `fs:exists?`."
    pathQuote fs:exists?
  ] @: exists?

  [ "( -- true/false ): same as `fs:readable?`"
    exists? pathQuote fs:readable? and
  ] @: readable?

  [ "( -- true/false ): same as `fs:dir?`."
    pathQuote fs:dir?
  ] @: dir?

  [ "( -- true/false ): same as `fs:file?`."
    pathQuote fs:file?
  ] @: file?

  [ "( -- true/false ): same as `fs:symlink?`."
    pathQuote fs:symlink?
  ] @: symlink?

  [ '<Path: ' ~ pathQuote ~ '>' ] @: *view

  this
] @: path


[ "( P -- F ): exchanges a Path block for a File block with
   file-related vocabulary."
  $: path

  path . exists?   $: exists?
  path . readable? $: readable?

  [ exists? not ] [ path . file? ] or not
    => [ 'File needs a file path, but got: ' path . *view stitch die ]

  [ "( -- Pq ): leaves the Path quote."
    path . pathQuote
  ] @: asQuote

  [ "( -- ): creates this file if it doesn't exist. Sets its
     access and modification times to current time."
    asQuote fs:touch

    true =: exists?
  ] @: touch

  [ "( contents: B -- ): makes an empty stack, leaves this
     file's contents quote on top there if this file exists
     and is readable."
    ahead eject $: block

    exists? readable? and =>
      [ asQuote fs:read enclose block hydrate ]
  ] @: contents:

  [ '<File at: ' asQuote stitch ~ '>' ] @: *view

  this
] @: file


1000 times: [ echo [ 1 2 3 ] each: [ 2 * echo ] ]

'hello.nk' path $: helloPath
helloPath . exists? echo "Should be false"
helloPath . file? echo   "Should be false"

helloPath file $: helloFile

helloFile . touch
helloFile . contents: [ 'Wrong!' echo ] "Should not run"

helloPath . exists? echo "Should be true."
helloPath . file? echo   "Should be true."
helloPath . dir? echo    "Should be false."