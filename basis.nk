"""
Novika basis file. Defines higher primitives in terms of lower
primitives, and gives Novika the Novika look-and-feel.

- Alexey Yurchenko, 2022
"""

"Create an entry for the first continuation (the block this comment
 belongs to), so it's easier to define new basis words."

world #conts pull 0 fromLeft dup #root swap pushes

root #conts [ "( -- C ): leaves Continuations block."
  world #conts pull
] opens

root #stack [ "( -- S ): leaves current stack block."
  world #stacks pull dup count 1 - fromLeft
] opens

root #<| [ "( -- ): moves current stack's cursor once to the left."
  stack dup |at 1 - |to
] opens

root #|> [ "( -- ): moves current stack's cursor once to the right."
  stack dup |at 1 + |to
] opens

root #over [ "( A B -- A B A ): duplicates over the ToS."
  <| dup |> swap
] opens

root #rot [ "( A B C -- B C A ): brings thirdmost item to front."
  <| swap |> swap
] opens

root #2dup [ "( A B -- A B A B ): duplicates a pair."
  over over
] opens

root #gulp [ "( E [ ... ] -- [ ... E ] -- ): adds Element to Block, drops both."
  swap shove
] opens

root #fromRight [
  "( B I -- E ): returns Index-th Element from the right
   in Block, I=0 is the last element."
  over count 1 - swap - fromLeft
] opens

root #<< [ "( [ ... ] E -- [ ... E] ): inserts Element into block."
  over gulp
] opens

root #>> [ "( [ ... E ] -- [ ... ] E ): removes Element from block, leaves both."
  dup cherry
] opens

root #reach [
  "( [ ... | E ] -- [ ... | ] -- E ): removes Element from block,
   Element is found after the cursor."
  #|> there cherry
] opens

root #enclose [ "( I -- [ I ] ): wraps Item in block."
  [ ] swap <<
] opens

root #2enclose [ "( I1 I2 -- [ I1 I2 ] ): wraps a pair of Items in block."
  swap

  [ ] swap <<
      swap <<
] opens

root #self [
  "( -- C ): leaves current continuation block, aka instance
   of this block."
  conts 2 fromRight
] opens

root #ahead [
  "( -- C ): leaves continuation of caller block. The primitive for
   runtime macros etc."
  conts 3 fromRight
] opens

root #there [ "( S B -- S ): activates Stack for the duration of Block."
  "We'll need to carry block thru the stack change,
   let's use table for that:"
  self #block rot opens

  world #stacks pull gulp
    block
  world #stacks pull cherry
] opens

root #@: [
  "( value @: name -- ): a shorthand for `block name value opens`,
   defines an opener under name in the caller table."
  ahead reach
  ahead swap rot opens
] opens

[ "( value $: name -- ): a shorthand for `block name value pushes`,
   defines a pusher under name in the caller table."
  ahead reach "( value name )"
  ahead swap rot pushes
] @: $:

[ "( value =: name -- ): a shorthand for `block name value submit`,
   updates an entry in caller's table or in tables of its parents."
  ahead reach "( value name )"
  ahead swap rot submit
] @: =:

[ "( [ ... T ) -- [ ... T ] T ): leaves block and its Top value."
  >> dup <| << |>
] @: tip

[ "( A B -- ): leaves whether two values are equal."
  same?
] @: =

[ "( A B -- B ): drop before top."
  swap drop
] @: nip

[ "( B -- true/false ): leaves whether Block is empty."
  count 0 =
] @: empty?

[ "( [ ... T ] cherry: B -- ): executes cherry on block. If that
   was done, opens Block. Otherwise does nothing."
  ahead reach @: body

  dup empty?
    [ drop ]        "Empty: do nothing."
    [ cherry body ] "Has some elements: cherry and open the block."
  br
] @: cherry:

[ "( B -- T ): activates an empty stack for the duration of Block,
   and leaves Top form in the stack. Dies if none."
  [ ] swap there cherry
] @: val

[ "( B -- ): activates an empty stack for the duration of Block."
  [ ] swap there drop
] @: do

[ "( D T F -- ? ): opens True/False forms depending on Determiner
   being true/false."
  sel open
] @: br

[ "( D => T -- ? ): opens True form if Determiner is truthy."
  ahead reach [ ] br
] @: =>

[ "( F -- I ): leaves Inverse of Form (false => true, else false)."
  false same?
] @: not

[ "( B -- ): makes detached continuations stack the stack for the
   duration of Block. Attaches after Block."
  conts detach
    "Don't forget to drop the call to continues (as it will obscure
     what the caller expects continuations block to be)"
    #drop there swap there
  conts attach
] @: continues

[ "( -- ): executes current continuation (current block) again.
   Looping primitive. You can exit via '.'. Normally prefer to
   use `while`, `loop`, etc. DOES NOTE REINSTANTIATE on iterations:
   make sure to use `new` in the right places."
  [
    drop "the call to 'again'"
    dup 0 |to
  ] continues
] @: again

[ "( B -- ): removes all blocks before, and including, B, from
   the continuations block (starting from the right)."
  [ "( B Conts -- Conts )"
    2dup cherry: [ "( B Conts B cherry )"
      same?
        [ nip ]
        [ breakImpl ]
      br
    ]
  ] @: breakImpl

  conts detach
    breakImpl
  conts attach
] @: break

"The three words below, `.`, `^`, and `while`, rely heavily on
 continuations clockwork & should be modified carefully. E.g.,
 replacing `sel open` with `br` will break these words because
 `br` is, after all, another continuation, and that violates
 a bunch of depth expectations (near `ahead break`). However,
 we are rapidly rising in abstraction here, so all that won't
 worry the end-users."

[ "( -- ): returns from the current continuation (current block). The
   weakest return."
   ahead prototype $: needle

   [
    prototype needle same?
      [ ahead break ] "Yes: break the loop."
      [ ]             "No: drop the continuation."
    sel open

    again
   ] continues

   "[unreachable]"
] @: .

[ "( -- ): returns to caller's parent block. Dies if none in the
   continuations stack."
  ahead prototype parent $: needle

  [
    dup prototype needle same?
      [ ahead break ] "Yes: break the loop."
      [ drop ]        "No: drop the continuation."
    sel open

    again
  ] continues

  "[unreachable]"
] @: ^

[ "( D B -- ): a primitive while loop taking a Determiner block and
   a Body block. Executes Determiner, Body in the same empty stack,
   each time new."
  2dup [ ] new rot there tip
    [ swap there drop ] "Yes: execute the block."
    [ drop "stack"      "No: break out of the loop."
      drop "block"
      drop "block"
      drop "determiner"
      ahead break ]
  sel open

  again
] @: while

[ "( D B -- ): opens Block while Determiner is false."
  $: body
  @: det
  [ det not ] body while
] @: until

[ "( N B -- ): repeats Block N times. Block is opened with current
   N on top of an empty stack."
  $: block
  $: n 0 $: i

  [ i n < ]
  [
    i enclose block there drop
    i 1 + =: i
  ] while
] @: times

[ "( N times: B -- ): infix variant of `times`."
  ahead reach "( N B )" times
] @: times:

[ "( L B -- ): opens Block with List as stack, cursor in List block
   after the each element."
  $: body
  $: list

  list 0 |to

  [ list dup |at 1 + over count = ]
  [
    "Due to a bug in |at/|to, we get wrong value (0),
     so must add 2."
    list dup |at 2 + |to
    list body there
  ] until
] @: |each

[ "( L B -- ): opens Block with each item in List on a new stack."
  $: block

  [ dup enclose block there drop ] |each
] @: each

[ "( L B -- L ): opens Block with each item in List, replaces the
   item with block's value."
  $: block dup

  [ enclose block there cherry ] |each
] @: map

[ "( A -- true/false ): leaves whether A = 0"
  0 =
] @: zero?

[ "( A B -- true/false ): leaves whether A is divisible by B."
  rem zero?
] @: /?

[ "( N -- true/false ): leaves whether A is even (divisible by two)."
  2 /?
] @: even?

[ "( N -- true/false ): leaves whether A is odd."
  even? not
] @: odd?

[ "( L pairs: B -- ): opens Block with pairs in List on a fresh
   stack. Does nothing if odd count in List."
  ahead reach $: block

  dup count even? => [ [ |> 2enclose block there drop ] |each ]
] @: pairs:

[ "( V [ D[ ... ] B[ ... ] ... ] ) -- B' ): finds Determiner which
   is truthy when opened with Value, and opens its Block. Each D
   and B are opened in a new stack (same for each D and B)."
  swap $: value

  pairs: [ "( D B )"
    value enclose rot there tip => [
      "Found a truthy determiner: execute its block and quit."
      swap there drop ^
    ]
  ]
] @: choose


"BUG: map inside `times` doesn't work, returns raw block. Guess
 somewhere block doesn't get 0 |to'd or something. `again` may
 be the one to blame."


[
  ahead reach +
] @: i+


1000 times: [
  echo
  [ 1 2 3 ]
  [ i+ 1 ]
  map echo

'3' [
  [ '1' = ] [ '1' echo ]
  [ '2' = ] [ '3' echo ]
  [ '3' = ] [ '5' echo ]
] choose

]
