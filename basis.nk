this #root this pushes

root #<| [
  "( -- ): moves stack cursor once to the left."
  stack |at 1 - stack swap |to
] opens


root #|> [
  "( -- ): moves stack cursor once to the right."
  stack |at 1 + stack swap |to
] opens


root #ahead [
  "( -- B ): leaves caller Block on the stack."
  conts dup count 3 - fromLeft #block entry:fetch
] opens


root #inject [
  "( B F -- ): inserts Form to Block: adds Form to Block,
   and moves cursor back again."
  <| dup |> shove dup |at 1 - |to
] opens


root #there [
  "( S B -- S ): opens Block in Stack, leaves Stack. Ahead
   is transferred to block."
  <| dup |> ahead #hydrate inject
] opens


root #eject [
  "( [ ... | F ... ]B -- [ ... | ... ]B -- F ): drops and
   leaves the Form after cursor in Block."
  [ |> ] there cherry
] opens


root #@: [
  "( F @: N ): makes an opener entry called Name for Form."
  ahead swap ahead eject swap opens
] opens

[ "( F $: N -- ): makes a pusher entry called Name for Form."
  ahead swap ahead eject swap pushes
] @: $:


[ "( V =: N -- ): submits Value to an already defined entry
   under the specified Name."
  ahead swap ahead eject swap submit
] @: =:


[ "( A B -- ): drops a pair of forms."
  drop drop
] @: 2drop


[ "( A B -- B ): drops over the top."
  swap drop
] @: nip


[	"( A B -- A B A ): duplicates over the top."
  <| dup |> swap
] @: over


[ "( A B C -- B C A ): brings thirdmost to the top."
  <| swap |> swap
] @: rot


[ "( A B C -- C A B ): makes top third from the top."
  rot rot
] @: -rot


[ "( A B -- A B A B ): duplicates a pair."
  over over
] @: 2dup


[ "( F [ ... ] -- [ ... F ] -- ): adds Form to Block, then
   drops both."
  swap shove
] @: gulp


[ "( [ ... ] F -- [ ... F ] ): inserts Form into block."
  over gulp
] @: <<


[ "( [ ... F ] -- [ ... ] F ): removes Form from block, leaves both."
  dup cherry
] @: >>


[ "( F -- [ F ] ): wraps Form in a new block."
  [ ] swap <<
] @: enclose


[ "( A B -- [ A B ] ): wraps a pair of forms in a new block."
  swap

  [ ] swap <<
      swap <<
] @: 2enclose


[ "( [ ... T ]B -- [ ... T ]B T ): leaves Block and its Top value."
  >> dup <| << |>
] @: top


[ "( B I -- F ): returns Index-th Form from right in Block;
   I = 0 is the last (rightmost) element."
  over count 1 - swap - fromLeft
] @: fromRight


[ "( T -> N -- F ): infix for `fetch`."
  ahead eject entry:fetch
] @: ->


[ "( T . N -- F ): same as `->`, but adds `open` ahead if the
   entry is an open(er) entry."
  ahead                $: caller
  ahead eject          $: name
  dup name entry:fetch $: form

  name entry:isOpenEntry? => [
    caller [ #open <| ] hydrate
  ]

  form
] @: .


[ "( A B -- true/false ): leaves whether two values are equal."
  same?
] @: =


[ "( A B -- true/false ): leaves whether A <= B."
  2dup < -rot = or
] @: <=


[ "( A B -- true/false ): leaves whether A > B."
  <= not
] @: >


[ "( A B -- true/false ): leaves whether A >= B."
  < not
] @: >=


[ "( A -- true/false ): leaves whether A = 0"
  0 =
] @: zero?


[ "( A B -- true/false ): leaves whether A is divisible by B."
  rem zero?
] @: /?


[ "( N -- true/false ): leaves whether A is even (divisible by two)."
  2 /?
] @: even?


[ "( N -- true/false ): leaves whether A is odd."
  even? not
] @: odd?


[ "( B -- true/false ): leaves whether Block is empty."
  count zero?
] @: empty?


[ "( F -- I ): leaves Inverse of Form (false => true, else false)."
  false same?
] @: not


[ "( F --  B ): leaves Form as Boolean."
  not not
] @: true?

[ "( B -- Bc ): takes a Block and leaves an empty Block child." 
  [ ] swap reparent
] @: child


[ "( B -- B' ): opens Block in the active stack."
  stack swap ahead #hydrate inject
] @: open


[ "( B -- T ): activates an empty stack for the duration of Block,
   and leaves Top form in the stack. Dies if none."
  [ ] swap there cherry
] @: val


[ "( B -- ): activates an empty stack for the duration of Block."
  [ ] swap hydrate
] @: do


[ "( D T F -- ? ): opens True/False forms depending on Determiner
   being true/false."
  sel open
] @: br


[ "( D => T -- ? ): opens True form if Determiner is truthy."
  ahead eject [ ] br
] @: =>


[ "( A B -- A/false ): leaves whether both A and B are truthy."
  $: b @: a

  a b false br
] @: and


[ "( A B -- true/A ): leaves whether A or B or both are truthy."
  $: b @: a
  
  a true b br
] @: or


[ "( T N fetch: B -- ): looks up under Name in Table block,
   and opens Block with that on ToS (on caller stack). If not
   found (or T is not block), does nothing."
  ahead eject @: block

  [ over block? ] [ 2dup entry:exists? ] and
    [ entry:fetch block ] "Has the entry, fetch and open block."
    [ 2drop             ] "Doesnt have, drop T N."
  br
] @: fetch:


[ "( B -- ): makes detached continuations stack the stack for
   the duration of Block. Attaches after Block."
  conts detach
    "Don't forget to drop the call to continues (as it will
     obscure what the caller expects continuations block to be)"
    [ drop ] there swap there
  conts attach
] @: continues


[ "( -- ): executes caller again. Looping primitive. Too low-
   level for users, prefer not to use (use `loop` instead).
   Beware that it does not re-instantiate the block."
  [
    drop "the call to repeat"
    dup -> block 0 |to
  ] continues
] @: repeat


[ "( B -- ): drops all continuations before (and including)
   those for which Block leaves truthy value when opened with
   the continuation on top of an empty stack, coming from the
   right-hand side."
  $: needle?

  [
    enclose needle? there cherry
      [ ]  "Hit the needle! Don't recurse."
      rec  "Not the needle. Recurse."
    br
  ] dup $: rec continues
] @: dropContinuationsUntil


[ "( -- ): returns to the CC of the block above the caller."
  ahead prototype parent $: above

  [ -> block prototype above same? ] dropContinuationsUntil
] @: ^


[ "( B -- I ): injects `break` and `continue` into an Instance
   of Block. `break` drops continuations until and including
   the caller block, and `continue`, drops them up to and
   including the Body block (and/or its instances)."
    dup $: body
    new $: instance
  ahead $: caller

  instance #break [ "( -- ): quits from the enclosing loop."
    [ -> block caller same? ] dropContinuationsUntil
  ] opens

  instance #continue [ "( -- ): quits from current loop iteration."
    [ -> block prototype body same? ] dropContinuationsUntil
  ] opens

  instance
] @: newWithBreakAndContinue


[ "( B -- ): basic infinite loop over Block. `break` and `continue`
   are made available in Block. Block is opened in an empty stack."
  newWithBreakAndContinue $: block

  [ "The actual loop body (note the `repeat`)."
    [ ] new block hydrate

    repeat
  ] open
] @: loop


[ "( loop: B -- ): prefix version of `loop`. Has no difference
   in regards to functionality."
  ahead eject loop
] @: loop:


[ "( C B -- ): opens Condition in an empty stack, Body in a
   new stack with Condition's result on top, all while Condition
   top is truthy after it's opened. Similar to `loop`, words `break`
   and `continue` are made available in Body."
  newWithBreakAndContinue $: body $: condition

  loop: [
    condition val dup
      [ enclose body hydrate ] "Condition truthy: enclose & proceed with body!"
      [ drop break ]           "Condition falsey: drop the false and get out."
    br
  ]
] @: while


[ "( while: C B -- ): prefix version of `while`. Has no difference
   in regards to functionality."
  ahead eject
  ahead eject
  while
] @: while:


[ "( C B -- ): inverse of `while` (opens Body while Condition
   is **false**), for more info see `while`."
  $: body @: condition

  [ condition not ] body while
] @: until


[ "( until: C B -- ): prefix version of `until`. Has no difference
   in regards to functionality."
  ahead eject
  ahead eject
  until
] @: until:


[ "( N B -- ): opens Body N times. Body is opened in a new
   stack with current N. `break` and `continue` available."
  newWithBreakAndContinue $: body $: stop

  0 $: start

  while: [ start stop < ] [
    start enclose body hydrate
    start 1 + =: start
  ]
] @: times


[ "( N times: B -- ): infix version of `times`."
  ahead eject times
] @: times:


[ """( Lb B -- Lb ): slides cursor in List block from left to right,
   in steps of one, and THEN opens Block with List block as the stack
   each step. Leaves List block. `break` and `continue` are available.

  >>> [ 1 2 3 ] dup 1 |to [ + ] |slideRight

  ! Sliding step is marked with '*', block iteration postfixed
    by a '+'.

   +------+-------+-------------+ 
   | #    | form  |    list     |
   +======+=======+=============+
   | 0    |       | [ 1 2 3 | ] |
   | 1    | 1 |to | [ 1 | 2 3 ] |
   | *    |       | [ 1 2 | 3 ] |
   | 3+   |    +  | [ 3 | 3 ]   |
   | *    |       | [ 3 3 | ]   |
   | 5+   |    +  | [ 6 | ]     |
   +------+-------+-------------+

  === [ 6 ]
  """
  newWithBreakAndContinue $: body $: list

  until: [ list dup |at over count = ]
  [
    list dup |at 1 + |to
    list body hydrate
  ]

  list
] @: |slideRight


[ "( Lb |-> B -- Lb ): infix version of `|slideRight`."
  ahead eject |slideRight
] @: |->


[ "( Lb B -- Lb ): similar to `|->`, but slides the cursor
   from right to left. Consult `|slideRight`."
  newWithBreakAndContinue $: body new $: list

  until: [ list |at 0 = ]
  [
    list count $: tmp
    list body hydrate
    list count tmp >= => [
      "If the amount of items in the list has not changed, or
       increased, slide leftwards."
       list dup |at 1 - |to
    ]
  ]

  list
] @: |slideLeft


[ "( Lb <-| B -- Lb ): infix version of `|slideLeft`."
  ahead eject |slideLeft
] @: <-|


[ """( Lb B -- ): opens Block with each item of List block on
   top of a new stack. List block is unchanged. `break` and
   `continue` are available.

  >>> [ 1 2 3 ] [ echo ] each
  STDOUT: 1
  STDOUT: 2
  STDOUT: 3
  """
  newWithBreakAndContinue $: block

  new dup 0 |to
    |-> [ dup enclose block hydrate ]
  drop
] @: each


[ """( Lb each: B -- ): infix version of `each`.

  >>> [ 1 2 3 ] each: [ echo ]
  STDOUT: 1
  STDOUT: 2
  STDOUT: 3
  """
  ahead eject each
] @: each:


[ """( Lb B -- ): opens Block with pairs of items from List block
   on top of an empty stack.

  >>> [ ] [ + echo ] pairs
  [Does nothing]

  >>> [ 1 ] [ + echo ] pairs
  >>> [ 1 2 3 ] [ + echo ] pairs
  [Dies: odd count]

  >>> [ 1 2 3 4 ] [ + echo ] pairs
  STDOUT: 3 (i.e., 1 + 2)
  STDOUT: 7 (i.e., 3 + 4)
  """
  $: block $: list

  list empty? => [ ^ ]

  list count odd? =>
    [ 'for pairs to work, there should be an even count of items in block' die ]
  
  list new dup 0 |to
    "Force cursor at 0. Also, we can safely drop below (and we do),
     since the block copy is ours thanks to `new`."
    |-> [ |> 2enclose block hydrate ]
  drop
] @: pairs


[ """( Lb pairs: B -- ): infix version of `pairs`.

  >>> [ 1 2 3 4 ] pairs: [ + echo ]
  STDOUT: 3
  STDOUT: 7
  """
  ahead eject pairs
] @: pairs:


[ """( Lb B -- ): opens Block with consequtive pairs of items
   from List block on top of an empty stack.
   
  >>> [ ] [ + echo ] consPairs
  >>> [ 1 ] [ + echo ] consPairs
  [Does nothing]

  >>> [ 1 2 ] [ + echo ] consPairs
  STDOUT: 3 (i.e, 1 + 2)

  >>> [ 1 2 3 ] [ + echo ] consPairs
  STDOUT: 3 (i.e., 1 + 2)
  STDOUT: 5 (i.e., 2 + 3)
  """
  $: block "( Lb )" dup empty? => [ drop ^ ]

  new dup 1 |to
    |-> [ 2dup 2enclose block hydrate ]
  drop
] @: consPairs


[ """( Lb B -- ): infix version of `consPairs`.
   
  >>> [ 1 2 3 ] consPairs: [ + echo ]
  STDOUT: 3
  STDOUT: 5
  """
  ahead eject consPairs
] @: consPairs:


[ """( Lb B -- MLb ): opens Block with each item of List block
   on top of an empty stack. Replaces item in List block with
   Block's stack top after opening it. Leaves the resulting
   Modified version of List block.

  >>> [ 1 2 3 ] [ 1 + ] map
  === [ 2 3 4 | ]

  >>> [ 1 2 3 ] $: a
  >>> a [ 1 + ] map
  === [ 2 3 4 | ]

  >>> a
  === [ 1 2 3 | ]
  """
  $: block "( Lb )"

  new dup 0 |to |-> [ enclose block there cherry ]
] @: map


[ """( Lb B -- MLb ): infix version of `map`.

  >>> [ 1 2 3 ] map: [ 1 + ]
  """
  ahead eject map
] @: map:


[ """( Lb B -- MLb ): opens Block with each item of List block
   on top of an empty stack. Removes that item in Modified List
   block if Block's stack top is false after it was opened.
   
  >>> [ ] [ 100 > ] only
  === [ | ] (a different block!)

  >>> [ 1 2 3 ] [ ] only
  === [ 1 2 3 | ] (a different block!)

  >>> [ 1 100 2 300 4 600 10 ] [ 100 > ] only
  === [ 300 600 | ]
  """
  $: block

  new dup 0 |to |-> [ $: item
    item enclose block there cherry
      [ item ] "Truthy value on Block's ToS: leave item."
      [      ] "Falsey value on Block's ToS: drop item."
    br
  ]
] @: only


[ """( Lb B -- MLb ): infix version of `only`.
  
  >>> [ 1 100 2 300 4 600 10 ] only: [ 100 > ]
  === [ 300 600 | ]
  """
  ahead eject only
] @: only:


[ """( Lb B M -- M ): reduces (google it if you don't know) List
   block using Block. Block is opened with Memo, current item on
   top of an empty stack. Memo is updated to Block's value after
   Block's opened.

  >>> [ ] [ + ] 0 reduce
  === 0

  >>> [ 1 ] [ + ] 0 reduce
  === 1 (i.e., 0 + 1)

  >>> [ 1 2 3 ] [ + ] 0 reduce
  === 6

  >>> [ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce
  === 'Hellope, Europe! Huh?'
  """
  $: default @: block

  new dup 0 |to
    default << |-> [ block ]
  cherry
] @: reduce


[ """( Lb B -- A ): leaves the Amount of items for which Block,
   when opened with an item on top of an empty stack, returns
   a truthy form.
  
  >>> [ 1 2 3 ] [ 2 > ] amount
  === 1 (i.e., 3)

  >>> [ 1 2 3 ] [ 100 > ] amount
  === 0

  >>> [ 1 5000 2 4400 1 100 102 ] [ 100 <= ] amount
  === 4 (i.e., 1, 2, 1, 100)
  """
  @: block 0 $: amt

  "Go thru each item and check if block opens to true there,
   if it does, increment the count."
  each: [ block => [ amt 1 + =: amt ] ]
  
  amt
] @: amount


[ """( Lb B -- A ): infix version of `amount`.

  >>> [ 1 2 3 ] # [ 2 > ]
  === 1
  """
  ahead eject amount
] @: #


[ """( Lb B -- true/false ): whether Block leaves true for all
   items in List block, when opened with each item on top of
   an empty stack.
   
  >>> [ ] [ 100 < ] all?
  === true (BEWARE)

  >>> [ 1 2 3 ] [ 100 < ] all?
  === true

  >>> [ 101 2 3 4 ] [ 100 < ] all?
  === false (i.e., because of 101)
  """
  @: block true $: status

  "Go thru each item and check if block opens to true there;
   if it doesn't, quit the loop with status = false."
  each: [ block not => [ false =: status break ] ] 

  status
] @: all?


[ """( Lb B -- true/false ): whether Block leaves true for any
   item in List block, when opened with each item on top of an
   empty stack.
  
  >>> [ ] [ 100 < ] any?
  === false (BEWARE)

  >>> [ 1 2 3 ] [ 3 = ] any?
  === true

  === [ 101 3 2000 ] [ 100 < ] any?
  === true (i.e., because of 3)

  >>> [ 1002 350 2000 ] [ 100 < ] any?
  === false
  """
  @: block false $: status

  "Go thru each item and check if block opens to true there;
   if it does, quit the loop with status = true."
  each: [ block => [ true =: status break ] ]

  status
] @: any?


[ "( F -- ): prints Form in the console. If Form is a block
   with *view word defined, opens *view in an empty stack
   and prints ToS form after *view there."
  dup #*view fetch: [
    "If there's a *echo word defined on the block, print
     whatever ToS it leaves."
    val rawEcho drop ^
  ]
  rawEcho
] @: echo


[ "( Q1 ~ Q2 -- Q ): infix Quote stitch (binary concatenation).
  TODOOOOOOOOO"
  ahead       $: caller
  ahead eject $: other 

  other dup word? => [ caller swap entry:fetch ] stitch
] @: ~


[ "( Pq -- P ): exchanges Path quote for a Path block with
   path-related vocabulary."
  $: pathQuote

  [ "( -- true/false ): same as `fs:exists?`."
    pathQuote fs:exists?
  ] @: exists?

  [ "( -- true/false ): same as `fs:readable?`"
    exists? pathQuote fs:readable? and
  ] @: available?

  [ "( -- true/false ): same as `fs:dir?`."
    pathQuote fs:dir?
  ] @: dir?

  [ "( -- true/false ): same as `fs:file?`."
    pathQuote fs:file?
  ] @: file?

  [ "( -- true/false ): same as `fs:symlink?`."
    pathQuote fs:symlink?
  ] @: symlink?

  [ '<Path: ' ~ pathQuote ~ '>' ] @: *view

  this
] @: path


[ "( P -- F ): exchanges a Path block for a File block with
   file-related vocabulary."
  $: path

  path . available? $: available?

  [ available? not ] [ path . file? ] or not
    => [ 'File needs a file path, but got: ' path . *view stitch die ]

  [ "( -- Pq ): leaves the Path quote."
    path . pathQuote
  ] @: asQuote

  [ "( -- ): creates this file if it doesn't exist. Sets its
     access and modification times to current time."
    asQuote fs:touch

    true =: available?
  ] @: touch

  [ "( contents: B -- ): makes an empty stack, leaves this
     file's contents quote on top there if this file exists
     and is readable."
    ahead eject $: block

    available? => [ asQuote fs:read enclose block hydrate ]
  ] @: contents:

  [ '<File at: ' asQuote stitch ~ '>' ] @: *view

  this
] @: file


[ "( R D -- ): copies the contents of Donor's table to Recipient,
   overriding the same-named entries in Recipient."
  $: donor $: recpt

  donor ls each: [ $: word
    donor word entry:fetch $: value

    recpt word value
      donor word entry:isOpenEntry?
        [ opens ]
        [ pushes ]
      br
  ]
] @: use:merge


[ "( Pq -- ): reads file(s) at Path quote (dies if not available),
   slurps into and opens in a root child, then merges the tables
   of root and that root child; in other words, implements primitive
   file-based importing."
  dup $: rawPath path $: usePath

  usePath . available? not =>
    [ 'the provided path (' ~ rawPath ~ ') does not exist' die ]

  usePath . dir? =>
    "TODO: Import all .nk files in the directory."
    [ 'unimplemented' ~ rawPath die ]
  
  usePath file $: asFile

  asFile . contents: [ $: fileContents
    "Evaluate the imported program in a root offspring,
     and in an empty stack."
    root child fileContents slurp $: foreignRoot

    foreignRoot 0 |to

    "Create a continuation, it will run immediately after
     the 'gulp'. Then execution will return after 'gulp'."
    [ ] foreignRoot newContinuation conts gulp

    root foreignRoot use:merge
  ]
] @: use


"'iters.test.nk' use"
'playground.nk' use